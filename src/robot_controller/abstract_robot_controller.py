"""
abstract_robot_controller.py

Contains AbstractRobotController, the root class for the robot controllers, an architecture which drives the robot
"""

class AbstractRCComponent:
    """The root class for robot controller components (rcco-*). A typical model is a neural network, but can be other things that visualize, log, memorize, visualize, perform safety checks etc.

    An RC component is described

    The main aspects of the model are:
    - **name** 
    - **architecture** the code that implements the component, or the structure of the neural network. This is normally created in the init or implemented as functions in inherited functions
    - **state** the data created through training. Can be loaded and saved. Example, weights of neural networks etc. 
    - **context** data accumulated during running, eg. LSTM state, transformer context. Can be loaded and saved. Normally the context is accumulated through the input
    - **input** the current input, which can be set without running the update. It might be saved with the context. 
        FIXME: it needs multiple named inputs
    - **output** the current output, generated by running the update. It has a marker whether it is up to date, i.e. if it had been generated from the current input. 
        FIXME: it needs multiple named outputs
    - **dirty** this bit verifies that the output(s) had been recalculated from the current inputs
    """
    def __init__(self, exp_rcc):
        self.input = None
        self.output = None
        self.dirty = False
    
    def set_input(self, input):
        """Sets the input. The most typical input is a torch tensor or a numpy array."""
        self.input = input
        self.dirty = True

    def propagate(self):
        """Propagate the input to the output, update the context, set the dirty flag"""
        self.dirty = False

    def save(self):
        """Save the state, context, input and output, to different files"""
        pass

    def load(self):
        """Load the state, context, input and output from different files"""
        pass


class AbstractRobotController:
    """The root class for robot controllers (roco-s). 
    It follows an asynchronous model. Various external entitites are adding observations, commands etc to it. 

    The main aspects of the model are:
    - A robot controller rc is a **directed graph** of rcco-s
    - A collection of rcco are specified in the exp, they have their internal name (related to exp), also a label internal to the ARC
    - The state of the rc, is the collection of the states of the rcco
    - The edges of the rc are outputs of rccos connected to inputs of other rccos
    - Inputs of the rc are those inputs that are not connected to outputs in the graph. These need to be filled externally.
    - Outputs of the rc, are things we want to read out. A specific output is the 
    - The final output is a command sent to the robot (real or simulated)
    """
    def __init__(self, exp_roco):
        """Initialize the various components of based on the passed exp"""
        self.exp = exp_roco
        self.components = []
    
    def add_input(label, value, time=None):
        """Adds an input at a specified time. This might involve various levels of memorization"""
        pass 

    def save(self):
        """Saves all the components"""
        for rcco in self.components:
            rcco.save()

    def load(self):
        """Loads all the components"""
        for rcco in self.components:
            rcco.load()

    def propagate(self):
        """Perform all the computations on the graph rcco-s, essentially propagating the data from the inputs to the outputs. This involves propagating on the rcco-s and performing the data transfers."""
        

class AbstractTrainingRecipe:
    """A class that encapsulates the training/finetuning of one or more robot controllers trec-*. It describes the training data, validation data, the initial state, final state. It contains the training code (or wraps it). 
    
    The main aspects of the training recipe are:
    -it refers to the training of one or more rccos over some training data
    -the rccos start from a specific state, this might be the result of previous training
    -it might also be real time, eg RL (not yet clear how to implement this)
    -it not all the rcco-s might be changing
    -those that had been changed will be written out under a new state, new exp
    -the output exps contain a log of the training

    -there might be a relationship to a full roco, but it does not necessarily have to instantiated here
    -it should have support for snapshots, recover from snapshots etc

    """
    def __init__(self, exp_trec):
        """Initialize the components of the trec, load the initial states"""
        pass 

    def train(self, cont_train = True):
        pass

    def load(self, snapshot_no = 0):
        """Loads the state at the specified snapshot"""
        pass
    
    def save(self, new_snapshot = True):
        """Saves the state as a new snapshot"""
        pass

    def export(self):
        """Export the newly trained rcco-s"""
        pass